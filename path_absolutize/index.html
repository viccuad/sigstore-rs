<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Path Absolutize"><meta name="keywords" content="rust, rustlang, rust-lang, path_absolutize"><title>path_absolutize - Rust</title><link rel="stylesheet" type="text/css" href="../normalize.css"><link rel="stylesheet" type="text/css" href="../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" type="text/css" href="../light.css"  id="themeStyle"><link rel="stylesheet" type="text/css" href="../dark.css" disabled ><link rel="stylesheet" type="text/css" href="../ayu.css" disabled ><script id="default-settings" ></script><script src="../storage.js"></script><script src="../crates.js"></script><script defer src="../main.js"></script>
    <noscript><link rel="stylesheet" href="../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../favicon.svg"><style type="text/css">#crate-search{background-image:url("../down-arrow.svg");}</style></head><body class="rustdoc mod crate"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="sidebar"><div class="sidebar-menu" role="button">&#9776;</div><a href='../path_absolutize/index.html'><div class='logo-container rust-logo'><img src='../rust-logo.png' alt='logo'></div></a><h2 class="location">Crate path_absolutize</h2><div class="block version"><div class="narrow-helper"></div><p>Version 3.0.11</p></div><div class="sidebar-elems"><a id="all-types" href="all.html"><p>See all path_absolutize's items</p></a><div class="block items"><ul><li><a href="#reexports">Re-exports</a></li><li><a href="#traits">Traits</a></li></ul></div><div id="sidebar-vars" data-name="path_absolutize" data-ty="mod" data-relpath=""></div><script defer src="sidebar-items.js"></script></div></nav><div class="theme-picker"><button id="theme-picker" aria-label="Pick another theme!" aria-haspopup="menu" title="themes"><img width="18" height="18" alt="Pick another theme!" src="../brush.svg"></button><div id="theme-choices" role="menu"></div></div><nav class="sub"><form class="search-form"><div class="search-container"><div><select id="crate-search"><option value="All crates">All crates</option></select><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"></div><button type="button" id="help-button" title="help">?</button><a id="settings-menu" href="../settings.html" title="settings"><img width="18" height="18" alt="Change settings" src="../wheel.svg"></a></div></form></nav><section id="main" class="content"><h1 class="fqn"><span class="in-band">Crate <a class="mod" href="#">path_absolutize</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span><span class="out-of-band"><span id="render-detail"><a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span><a class="srclink" href="../src/path_absolutize/lib.rs.html#1-395" title="goto source code">[src]</a></span></h1><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><h2 id="path-absolutize" class="section-header"><a href="#path-absolutize">Path Absolutize</a></h2>
<p>This is a library for extending <code>Path</code> and <code>PathBuf</code> in order to get an absolute path and remove the containing dots.</p>
<p>The difference between <code>absolutize</code> and <code>canonicalize</code> methods is that <code>absolutize</code> does not care about whether the file exists and what the file really is.</p>
<p>Please read the following examples to know the parsing rules.</p>
<h3 id="examples" class="section-header"><a href="#examples">Examples</a></h3>
<p>There are two methods you can use.</p>
<h4 id="absolutize" class="section-header"><a href="#absolutize">absolutize</a></h4>
<p>Get an absolute path.</p>
<p>The dots in a path will be parsed even if it is already an absolute path (which means the path starts with a <code>MAIN_SEPARATOR</code> on Unix-like systems).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;/path/to/123/456&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;/path/to/123/456&quot;</span>, <span class="ident">p</span>.<span class="ident">absolutize</span>().<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;/path/to/./123/../456&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;/path/to/456&quot;</span>, <span class="ident">p</span>.<span class="ident">absolutize</span>().<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());</code></pre></div>
<p>If a path starts with a single dot, the dot means your program’s <strong>current working directory</strong> (CWD).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;
<span class="kw">use</span> <span class="ident">std::env</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;./path/to/123/456&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="ident">Path::join</span>(<span class="ident">env::current_dir</span>().<span class="ident">unwrap</span>().<span class="ident">as_path</span>(), <span class="ident">Path::new</span>(<span class="string">&quot;path/to/123/456&quot;</span>)).<span class="ident">to_str</span>().<span class="ident">unwrap</span>(), <span class="ident">p</span>.<span class="ident">absolutize</span>().<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());</code></pre></div>
<p>If a path starts with a pair of dots, the dots means the parent of the CWD. If the CWD is <strong>root</strong>, the parent is still <strong>root</strong>.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;
<span class="kw">use</span> <span class="ident">std::env</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;../path/to/123/456&quot;</span>);

<span class="kw">let</span> <span class="ident">cwd</span> <span class="op">=</span> <span class="ident">env::current_dir</span>().<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">cwd_parent</span> <span class="op">=</span> <span class="ident">cwd</span>.<span class="ident">parent</span>();

<span class="kw">match</span> <span class="ident">cwd_parent</span> {
   <span class="prelude-val">Some</span>(<span class="ident">cwd_parent</span>) =&gt; {
       <span class="macro">assert_eq!</span>(<span class="ident">Path::join</span>(<span class="kw-2">&amp;</span><span class="ident">cwd_parent</span>, <span class="ident">Path::new</span>(<span class="string">&quot;path/to/123/456&quot;</span>)).<span class="ident">to_str</span>().<span class="ident">unwrap</span>(), <span class="ident">p</span>.<span class="ident">absolutize</span>().<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());
   }
   <span class="prelude-val">None</span> =&gt; {
       <span class="macro">assert_eq!</span>(<span class="ident">Path::join</span>(<span class="ident">Path::new</span>(<span class="string">&quot;/&quot;</span>), <span class="ident">Path::new</span>(<span class="string">&quot;path/to/123/456&quot;</span>)).<span class="ident">to_str</span>().<span class="ident">unwrap</span>(), <span class="ident">p</span>.<span class="ident">absolutize</span>().<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());
   }
}</code></pre></div>
<p>A path which does not start with a <code>MAIN_SEPARATOR</code>, <strong>Single Dot</strong> and <strong>Double Dots</strong>, will act like having a single dot at the start when <code>absolutize</code> method is used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;
<span class="kw">use</span> <span class="ident">std::env</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;path/to/123/456&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="ident">Path::join</span>(<span class="ident">env::current_dir</span>().<span class="ident">unwrap</span>().<span class="ident">as_path</span>(), <span class="ident">Path::new</span>(<span class="string">&quot;path/to/123/456&quot;</span>)).<span class="ident">to_str</span>().<span class="ident">unwrap</span>(), <span class="ident">p</span>.<span class="ident">absolutize</span>().<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;
<span class="kw">use</span> <span class="ident">std::env</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;path/../../to/123/456&quot;</span>);

<span class="kw">let</span> <span class="ident">cwd</span> <span class="op">=</span> <span class="ident">env::current_dir</span>().<span class="ident">unwrap</span>();

<span class="kw">let</span> <span class="ident">cwd_parent</span> <span class="op">=</span> <span class="ident">cwd</span>.<span class="ident">parent</span>();

<span class="kw">match</span> <span class="ident">cwd_parent</span> {
   <span class="prelude-val">Some</span>(<span class="ident">cwd_parent</span>) =&gt; {
       <span class="macro">assert_eq!</span>(<span class="ident">Path::join</span>(<span class="kw-2">&amp;</span><span class="ident">cwd_parent</span>, <span class="ident">Path::new</span>(<span class="string">&quot;to/123/456&quot;</span>)).<span class="ident">to_str</span>().<span class="ident">unwrap</span>(), <span class="ident">p</span>.<span class="ident">absolutize</span>().<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());
   }
   <span class="prelude-val">None</span> =&gt; {
       <span class="macro">assert_eq!</span>(<span class="ident">Path::join</span>(<span class="ident">Path::new</span>(<span class="string">&quot;/&quot;</span>), <span class="ident">Path::new</span>(<span class="string">&quot;to/123/456&quot;</span>)).<span class="ident">to_str</span>().<span class="ident">unwrap</span>(), <span class="ident">p</span>.<span class="ident">absolutize</span>().<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());
   }
}</code></pre></div>
<h4 id="absolutize_virtually" class="section-header"><a href="#absolutize_virtually">absolutize_virtually</a></h4>
<p>Get an absolute path <strong>only under a specific directory</strong>.</p>
<p>The dots in a path will be parsed even if it is already an absolute path (which means the path starts with a <code>MAIN_SEPARATOR</code> on Unix-like systems).</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;/path/to/123/456&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;/path/to/123/456&quot;</span>, <span class="ident">p</span>.<span class="ident">absolutize_virtually</span>(<span class="string">&quot;/&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;/path/to/./123/../456&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;/path/to/456&quot;</span>, <span class="ident">p</span>.<span class="ident">absolutize_virtually</span>(<span class="string">&quot;/&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());</code></pre></div>
<p>Every absolute path should under the virtual root.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;

<span class="kw">use</span> <span class="ident">std::io::ErrorKind</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;/path/to/123/456&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="ident">ErrorKind::InvalidInput</span>, <span class="ident">p</span>.<span class="ident">absolutize_virtually</span>(<span class="string">&quot;/virtual/root&quot;</span>).<span class="ident">unwrap_err</span>().<span class="ident">kind</span>());</code></pre></div>
<p>Every relative path should under the virtual root.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;

<span class="kw">use</span> <span class="ident">std::io::ErrorKind</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;./path/to/123/456&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="ident">ErrorKind::InvalidInput</span>, <span class="ident">p</span>.<span class="ident">absolutize_virtually</span>(<span class="string">&quot;/virtual/root&quot;</span>).<span class="ident">unwrap_err</span>().<span class="ident">kind</span>());</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;

<span class="kw">use</span> <span class="ident">std::io::ErrorKind</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;../path/to/123/456&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="ident">ErrorKind::InvalidInput</span>, <span class="ident">p</span>.<span class="ident">absolutize_virtually</span>(<span class="string">&quot;/virtual/root&quot;</span>).<span class="ident">unwrap_err</span>().<span class="ident">kind</span>());</code></pre></div>
<p>A path which does not start with a <code>MAIN_SEPARATOR</code>, <strong>Single Dot</strong> and <strong>Double Dots</strong>, will be located in the virtual root after the <code>absolutize_virtually</code> method is used.</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;path/to/123/456&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;/virtual/root/path/to/123/456&quot;</span>, <span class="ident">p</span>.<span class="ident">absolutize_virtually</span>(<span class="string">&quot;/virtual/root&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());</code></pre></div>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;path/to/../../../../123/456&quot;</span>);

<span class="macro">assert_eq!</span>(<span class="string">&quot;/virtual/root/123/456&quot;</span>, <span class="ident">p</span>.<span class="ident">absolutize_virtually</span>(<span class="string">&quot;/virtual/root&quot;</span>).<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());</code></pre></div>
<h3 id="caching" class="section-header"><a href="#caching">Caching</a></h3>
<p>By default, the <code>absolutize</code> method and the <code>absolutize_virtually</code> method create a new <code>PathBuf</code> instance of the CWD every time in their operation. The overhead is obvious. Although it allows us to safely change the CWD at runtime by the program itself (e.g. using the <code>std::env::set_current_dir</code> function) or outside controls (e.g. using gdb to call <code>chdir</code>), we don’t need that in most cases.</p>
<p>In order to parse paths with better performance, this crate provides three ways to cache the CWD.</p>
<h4 id="once_cell_cache" class="section-header"><a href="#once_cell_cache">once_cell_cache</a></h4>
<p>Enabling the <code>once_cell_cache</code> feature can let this crate use <code>once_cell</code> to cache the CWD. It’s thread-safe and does not need to modify any code, but once the CWD is cached, it cannot be changed anymore at runtime.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.path-absolutize]
version = &quot;*&quot;
features = [&quot;once_cell_cache&quot;]</code></pre></div><h4 id="lazy_static_cache" class="section-header"><a href="#lazy_static_cache">lazy_static_cache</a></h4>
<p>Enabling the <code>lazy_static_cache</code> feature can let this crate use <code>lazy_static</code> to cache the CWD. It’s thread-safe and does not need to modify any code, but once the CWD is cached, it cannot be changed anymore at runtime.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.path-absolutize]
version = &quot;*&quot;
features = [&quot;lazy_static_cache&quot;]</code></pre></div><h4 id="unsafe_cache" class="section-header"><a href="#unsafe_cache">unsafe_cache</a></h4>
<p>Enabling the <code>unsafe_cache</code> feature can let this crate use a mutable static variable to cache the CWD. It allows the program to change the CWD at runtime by the program itself, but it’s not thread-safe.</p>
<p>You need to use the <code>update_cwd</code> function to initialize the CWD first. The function should also be used to update the CWD after the CWD is changed.</p>
<div class="example-wrap"><pre class="language-toml"><code>[dependencies.path-absolutize]
version = &quot;*&quot;
features = [&quot;unsafe_cache&quot;]</code></pre></div>
<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">extern</span> <span class="kw">crate</span> <span class="ident">path_absolutize</span>;

<span class="kw">use</span> <span class="ident">std::path::Path</span>;

<span class="kw">use</span> <span class="ident">path_absolutize</span>::<span class="kw-2">*</span>;

<span class="kw">unsafe</span> {
    <span class="ident">update_cwd</span>();
}

<span class="kw">let</span> <span class="ident">p</span> <span class="op">=</span> <span class="ident">Path::new</span>(<span class="string">&quot;./path/to/123/456&quot;</span>);

<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">p</span>.<span class="ident">absolutize</span>().<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());

<span class="ident">std::env::set_current_dir</span>(<span class="string">&quot;/&quot;</span>).<span class="ident">unwrap</span>();

<span class="kw">unsafe</span> {
    <span class="ident">update_cwd</span>();
}

<span class="macro">println!</span>(<span class="string">&quot;{}&quot;</span>, <span class="ident">p</span>.<span class="ident">absolutize</span>().<span class="ident">unwrap</span>().<span class="ident">to_str</span>().<span class="ident">unwrap</span>());</code></pre></div>
<h3 id="benchmark" class="section-header"><a href="#benchmark">Benchmark</a></h3><h5 id="no-cache" class="section-header"><a href="#no-cache">No-cache</a></h5><div class="example-wrap"><pre class="language-bash"><code>cargo bench</code></pre></div><h5 id="once_cell_cache-1" class="section-header"><a href="#once_cell_cache-1">once_cell_cache</a></h5><div class="example-wrap"><pre class="language-bash"><code>cargo bench --features once_cell_cache</code></pre></div><h5 id="lazy_static_cache-1" class="section-header"><a href="#lazy_static_cache-1">lazy_static_cache</a></h5><div class="example-wrap"><pre class="language-bash"><code>cargo bench --features lazy_static_cache</code></pre></div><h5 id="unsafe_cache-1" class="section-header"><a href="#unsafe_cache-1">unsafe_cache</a></h5><div class="example-wrap"><pre class="language-bash"><code>cargo bench --features unsafe_cache</code></pre></div></div></details><h2 id="reexports" class="small-section-header"><a href="#reexports">Re-exports</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left"><code>pub extern crate <a class="mod" href="../path_dedot/index.html" title="mod path_dedot">path_dedot</a>;</code></div></div></div><h2 id="traits" class="small-section-header"><a href="#traits">Traits</a></h2>
<div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="trait" href="trait.Absolutize.html" title="path_absolutize::Absolutize trait">Absolutize</a></div><div class="item-right docblock-short"><p>Let <code>Path</code> and <code>PathBuf</code> have <code>absolutize</code> and <code>absolutize_virtually</code> method.</p>
</div></div></div></section><section id="search" class="content hidden"></section><div id="rustdoc-vars" data-root-path="../" data-current-crate="path_absolutize" data-search-index-js="../search-index.js" data-search-js="../search.js"></div>
</body></html>